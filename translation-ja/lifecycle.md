# リクエストのライフサイクル

- [イントロダクション](#introduction)
- [ライフサイクル概論](#lifecycle-overview)
    - [最初のステップ](#first-steps)
    - [HTTP／コンソールカーネル](#http-console-kernels)
    - [サービスプロバイダ](#service-providers)
    - [ルート](#routing)
    - [最後](#finishing-up)
- [サービスプロバイダに注目](#focus-on-service-providers)

<a name="introduction"></a>
## イントロダクション

「現実の世界」でツールを使用するとき、そのツールがどのように機能するかを理解していれば、より自信を感じられます。アプリケーション開発も例外ではありません。開発ツールがどのように機能するかを理解すると、それらをより快適に、自信を持って使用できるようになります。

このドキュメントの目的は、Laravelフレームワークがどのように機能するかについての概要を説明することです。フレームワーク全体をよりよく理解することで、すべてが「魔法」ではなくなり、アプリケーションの構築に自信が持てるようになります。すべての用語をすぐに理解できない場合でも、戸惑う必要はありません。何が起こっているのかという基本的な部分を把握しておけば、ドキュメントの他のセクションを探索するにつれて知識が深まります。

<a name="lifecycle-overview"></a>
## ライフサイクル概論

<a name="first-steps"></a>
### 最初のステップ

Laravelアプリケーションへのすべてのリクエストのエントリポイントは`public/index.php`ファイルです。すべてのリクエストは、Webサーバ(Apache/Nginx)設定によってこのファイルに送信されます。`index.php`ファイルには多くのコードが含まれていません。むしろ、フレームワークの残りの部分をロードするための開始点と言えるでしょう。

`index.php`ファイルは、Composerで生成したオートローダー定義をロードし、Laravelアプリケーションのインスタンスを`bootstrap/app.php`から取得します。Laravel自体が取る最初のアクションは、アプリケーション／[サービスコンテナ](/docs/{{version}}/container)のインスタンスを作成することです。

<a name="http-console-kernels"></a>
### HTTP／コンソールカーネル

次に、アプリケーションインスタンスの`handleRequest`メソッドまたは`handleCommand`メソッドを使い、アプリケーションが受け取るリクエストのタイプに応じて、HTTPカーネルまたはコンソールカーネルへリクエストが送られます。これら２つのカーネルは、すべてのリクエストが流れる中心的な場所として機能します。今回は、`Illuminate\Foundation\Http\Kernel`インスタンスであるHTTPカーネルへ注目してみましょう。

HTTPカーネルはリクエストを処理する前に実行する、 初期起動処理（`bootstrappers`）の配列を定義しています。これらの初期起動処理は、エラー処理の設定、ログの設定、[アプリケーション環境の検出](/docs/{{version}}/configuration#environment-configuration)など、リクエストを実際に処理する前に行う必要のあるタスクを実行します。通常、これらのクラスは、あなたが心配する必要のないLaravel内部の設定を処理します。

HTTPカーネルは、アプリケーションのミドルウェアスタックへリクエストを渡す役割も担います。これらのミドルウェアは、[HTTPセッション](/docs/{{version}}/session)の読み書き、アプリケーションがメンテナンスモードかどうかの判断、[CSRFトークンの検証](/docs/{{version}}/csrf)などを処理します。これらについてはこのあとに、詳しく説明します。

HTTPカーネルの`handle`メソッドの引数は非常に単純です。`Request`を受け取り、`Response`を返します。カーネルをアプリケーション全体を表す大きなブラックボックスであると考えてください。HTTPリクエストを取り込み、HTTPレスポンスを返します。

<a name="service-providers"></a>
### サービスプロバイダ

最も重要なカーネル初期起動アクションの1つは、アプリケーションの[サービスプロバイダ](/docs/{{version}}/providers)をロードすることです。サービスプロバイダは、データベース、キュー、バリデーション、ルーティングコンポーネントなど、フレームワークのさまざまなコンポーネントをすべて初期起動処理する役割を担っています。

Laravelはこのプロバイダのリストを繰り返し処理し、それぞれをインスタンス化します。プロバイダをインスタンス化した後、すべてのプロバイダの`register`メソッドを呼び出します。次に、すべてのプロバイダを登録し、各プロバイダで`boot`メソッドを呼び出します。これは、`boot`メソッドが実行されるまでに、すべてのコンテナバインディングが登録され、利用可能になっていることに、サービスプロバイダが依存しているからです。

Laravelが提供する基本的なすべての主機能は、サービスプロバイダによって初期起動および設定されます。フレームワークによって提供される非常に多くの機能を初期起動し設定するため、サービスプロバイダはLaravel初期起動プロセス全体の最も重要な側面です。

フレームワークは内部的に何十ものサービスプロバイダを使いますが、あなた自身のものを作るオプションもあります。`bootstrap/providers.php`ファイルで、アプリケーションが使用しているユーザー定義またはサードパーティーのサービス・プロバイダのリストを見つけることができます。

<a name="routing"></a>
### ルート

アプリケーションが初期起動され、すべてのサービスプロバイダが登録されると、`Request`がルータに渡されてディスパッチされます。ルータは、ルートまたはコントローラへリクエストをディスパッチし、ルート固有のミドルウェアを実行します。

ミドルウェアはアプリケーションが受け取る、HTTPリクエストをフィルタリングまたは検査する便利なメカニズムを提供します。例えば、Laravelには、アプリケーションのユーザーが認証済みかを確認するミドルウェアがあります。ユーザーが認証されていない場合、ミドルウェアはユーザーをログイン画面にリダイレクトします。しかし、ユーザーが認証済であれば、ミドルウェアはリクエストをアプリケーションへ進めます。ミドルウェアの中には `PreventRequestsDuringMaintenance`のように、アプリケーション内のすべてのルートに割り当てられるものもあれば、特定のルートやルートグループにのみ割り当てられるものもあります。ミドルウェアの詳細については、[ミドルウェアのドキュメント](/docs/{{version}}/middleware)を読んでください。

リクエストが一致したルートへ割り当てられたすべてのミドルウェアをパスした場合は、ルートまたはコントローラメソッドが実行され、ルートまたはコントローラメソッドが返すレスポンスがルートのミドルウェアチェーンを介して返送されます。

<a name="finishing-up"></a>
### 最後

ルートまたはコントローラメソッドがレスポンスを返すと、レスポンスはルートのミドルウェアを介して外側に戻り、アプリケーションに送信レスポンスを変更または検査する機会を与えます。

最後に、レスポンスがミドルウェアを経由して戻ってくると、HTTPカーネルの`handle`メソッドはレスポンスオブジェクトをアプリケーションインスタンスの`handleRequest`へ返し、このメソッドは返されたレスポンスに対して`send`メソッドを呼び出します。`send`メソッドはレスポンスの内容をユーザーのウェブブラウザに送信します。これで、Laravelのリクエストライフサイクル全体の旅が終わりました！

<a name="focus-on-service-providers"></a>
## サービスプロバイダに注目

サービスプロバイダは、Laravelアプリケーションを初期起動するための真の鍵です。アプリケーションインスタンスが作成され、サービスプロバイダが登録され、リクエストが初期起動を終えたアプリケーションに渡されます。とても簡単です！

Laravelアプリケーションをどのように構築し、サービスプロバイダを経由して初期起動処理するかをしっかり把握することは、非常に価値があります。アプリケーションのユーザー定義サービスプロバイダは、`app/Providers`ディレクトリに保存します。

デフォルトの`AppServiceProvider`はほとんど空です。このプロバイダは、アプリケーション独自の初期起動処理およびサービスコンテナ結合を追加するのに最適な場所です。大規模なアプリケーションの場合、アプリケーションで使用する特定のサービスに対して、それぞれがよりきめ細かい初期処理を備えた複数のサービスプロバイダを作成することをお勧めします。
